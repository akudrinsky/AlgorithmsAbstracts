\section{Хеш-таблицы с открытым ключем. Фильтры. Кукушкино хеширование}%
\label{sec:Хеш-таблицы с открытым ключем. Фильтры. Кукушкино хеширование}
\subsection{Открытый ключ}%
\label{sub:Открытый ключ}

У нас все еще есть некоторый универсум $U$, из которого берутся  $N$ ключей, а также есть хеш-функция, 
с помощью которой мы хотим хранить набор ключей, осуществляя добавление, удаление и поиск элементов. \\

Заведем  $M$ ячеек, и при добавлении элемента будем считать его хеш по модулю  $M$, за тем :
\begin{itemize}
    \item Если ячейка свободна, просто запишем элемент.
    \item Если же слот занят, то просто пойдем направо, пока не найдем свободную ячейку.
\end{itemize}
Такой подход называется \textbf{линейное пробирование}.

\subsubsection{Линейное пробирование}
Введем обозначение $run(x, i) = (h(x) + i) \% M$, где $x$ --- ключ, а  $i$ --- номер попытки. 
Если в нашей таблице есть свободные ячейки, то рано или поздно мы их найдем, однако рано или поздно 
таблица заполнится, в этом случае мы просто увеличиваем массив в два раза, выбираю новую хеш-функцию 
и заново вставляя все элементы. 

Чтобы произвести поиск элемента  $x$ нужно рассмотреть ячейку  $h(x)$:
 \begin{itemize}
    \item Если ячейка свободна, то $x$ нет в таблице
    \item В противном случае, проверяем этот элемент на равенство с $x$, если он не совпадает, 
        то $x$ нужно искать в следующих ячейках по линейному $run$. Таким образом идем до первой пустой ячейки или пока не найдем $x$.
\end{itemize}

Чтобы удалить элемент $x$, кажется разумным просто идти по линейному $run$ пока не попадем в пустую ячейки или найдем $x$ и очистить его ячейку,
однако в случае если имеется элемент $y: h(y) = h(x)$, очистив ячейку, в которой лежал $x$, мы сломаем алгоритм поиска $y$. \\
Чтобы этого избежать будем не очищать ячейку, а ставить в ней \textit{tombstone}, говорящий о том, что значение существовало, но было удалено.

Тогда очевидным образом придется модифицировать функцию поиска, теперь она должна будет встретив  \textit{tombstone} идти дальше по $run$. 
Функция добавления теперь будет вставлять элемент не только в случае если она нашла пустое место, но и в случае попадания на \textit{tombstone}. 


Не смотря на то, что такой подход хорошо ложится на кэш, он имеет очевидную проблему: $run$ может длиться долго, 
например если рядом будет лежать большое количество значений с одинаковым хешем. Однако удачный выбор хеш-функции позволяет этой проблемы избежать.

\begin{Def}
    \textbf{K-independent Hashing} --- хеш-функция обладает свойством $\forall x_1, ..., x_k \hookrightarrow h(x_1), h(x_2), ..., h(x_k)$ --- независимые в совокупности случайные величины.
\end{Def}

Северокорейские ученые доказали, что если для линейного пробирования взять 2-independent хеш, 
то мат. ожидание времени работы по перебору ячеек $O(\sqrt{n})$, 3-independent ---  $O(\log{n})$, 5-independent ---  $O(1)$ \\
Простых примеров 5-independent хеш-функций пока не найдено.

\begin{theorem}
    Если функция 2-independent, а во входных данных достаточно энтропии, то для времени работы достигается оценка $O(1)$. 
\end{theorem}

То есть в реальной жизни, гда данные хорошо распределены, достаточно 2-independent функции. 

\subsubsection{Квадратичное пробирование}
$run(x, i) = (h(x) + (-1)^i i^2$ 

\subsubsection{Двойное хеширование}
Зафиксируем две хеш-функции $h_1$ и  $h_2$, тогда  $run(x, i) = (h_1(x) + h_2(x) \cdot i) \% M$ \\
То есть длину прыжка мы параметризуем входными данными. \\
В таком случай северокорейские ученые говорят, что если $h_1, h_2$ --- 2-independent, то мат. ожидание времени работы  $O(1)$

\subsubsection{Кукушкино хеширование}
Заведем две хеш-функции $h_1$ и  $h_2$, а также две Хеш-таблицы с одинаковым количеством ячеек.

Теперь, чтобы вставить элемент  $x$:
\begin{enumerate}
    \item Положим элемент в первую таблицу. 
    \item Если если ячейка была занята, вытесним старый элемент и положим его во вторую таблицу.
    \item Если при добавлении элемента во вторую таблицу, какой-то ключ был вытеснен, положим его в первую таблицу.
    \item Будем повторять эти действия до тех пор пока не уложим все элементы или не попадем в бесконечный цикл.
    \item Если мы попали в цикл произведем rehash.
\end{enumerate}

\begin{theorem}
    Мат. ожидание времени одной вставки вставки составляет $O(1)$. \\
    При этом на $m$ вставок время работы составляет  $O(1)$ с вероятностью  $1 - O(\frac{1}{m})$
\end{theorem}

\subsection{Фильтры}

Мы хотим решать задачу проверки принадлежности объекта множеству, мы уже оптимизировали время работы, однако 
хочется уметь отвечать на все те же вопросы не тратя много памяти. 

\subsubsection{Фильтр Блума}
Для увеличения эффективности по памяти пожертвуем чуть-чуть корректностью нашей структуры, то есть разрешим ложно-положительные ответы с некоторой вероятностью $\varepsilon$, 
но однозначно запретим ложно-отрицательные.

Заведем  $k$ равномерных хеш-функций и битовый массив размера  $M$.  

Теперь, чтобы добавить элемент $x$, вычислим значения всех $k$ хеш-функций, и для каждого из значений выставим в массиве бит, порядковый номер которого равен этому значению.
Если бит уже был выставлен, то его не нужно менять.

Тогда чтобы проверить наличие элемента, нужно посчитать значения хеш-функций и проверит выставленность битов.

\paragraph{Вероятность ошибки}
Чтобы ошибка произошла нужно, чтобы у отсутствующего в таблице ключа были выставлены все биты. \\
Пусть у нас вставляется один ключ, посчитаем вероятность с которой в заданный бит будет выставлена единица.
Из не совсем верного предположения независимости битов можем сделать грубую оценку: \\
После вычисления $h_1$ имеем вероятность того, что бит не был выставлен  $ 1 - \frac{1}{M}$, ведь функция равномерна. \\
Тогда вероятность того, что бит был выставлен после добавления $n$ ключей ---  $1 - \left (1 - \frac{1}{M} \right) ^{k \cdot n}$ \\
Значит вероятность того, что конкретные $k$ бит были выставлены составляет  $\left( 1 - \left(1 - \frac{1}{M}\right) ^{k \cdot n}\right) ^k$

Оценка без предположения независимости на самом деле $\frac{1}{M^{k(n + 1)}} \cdot \sum \limits _{i = 1}^{M} i^k \cdot C_m ^ i \cdot F(kn, i)$, 
где $F(kn, i)$ --- число сюръекций из множества размера $kn$ в множество размера  $i$.

В силу естественных причин мы воспользуемся грубой оценкой.

\paragraph{Оптимальное количество хеш-функций}
Анализ показывает что оптимум при фиксированных $N$ и  $M$ составляет  $\frac{M}{N} \cdot \log{2}$. \\
При фиксированных $N$ и  $\varepsilon$ --- $M = \frac{n \log{\varepsilon}}{(\log{2})^2} \Rightarrow M \approx 1.44 \log_2{\frac{1}{\varepsilon}}$ и $k = \log_2{\frac{1}{\varepsilon}}$

\paragraph{Применение} фильтра Блума часто имеет место в базах данных, которые сначала пропускают запрос через быстрый фильтр, отклоняющий неинтересные запросы.

\paragraph{Существенный недостаток} фильтра Блума заключается в том, что нельзя просто взять и удалить элемент.

\subsubsection{Кукушкин фильтр}
Так же быстр, но позволяет удалять элемент.
Заведем две таблицы, в которых будем хранить \textit{отпечатки ключей} --- битовые строки $f(k)$. \\
Для того чтобы удобно переносить значения из одной таблицы в другую, нам нужно уметь быстро считать $h_1$ и $h_2$ по отпечатку ключа. \\
Зафиксируем $h_1(x) = hash(x)$. Тогда примем $h_2(x) = h_1(x) \oplus hash(f(x))$. \\
Тогда имея одну из хеш-функций и $f$ мы легко можем посчитать другую. \\

Не смотря на то, что пространство $f(x)$ сильно уже пространства $x$, это не влияет на производительность. \\
На один объект в кукушкином фильтре используется $\frac{\log_2(1/\varepsilon) + 3}{\alpha}$, где $\alpha$ это показатель загруженности.


 
