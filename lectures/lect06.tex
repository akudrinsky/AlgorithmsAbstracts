\section{Алгоритм Ахо -- Корасик для нахождения всех вхождений набора подстрок.}%

\begin{Def}
	\textbf{Бор} --- дерево, в котором каждая вершина обозначает строку, а каждое ребро обозначает букву. Строка, соответсвующая вершине (то есть в ней заканчивающаяся), получается конкатенацией всех букв, соответсвующих ребрам пути из корня в эту самую вершину. По определению, корню бора соответствует пустая строка.
\end{Def}

\begin{Def}
	\textbf{Терминальная вершина} бора для набора слов --- вершина, которой соответствует слово из этого набора.
\end{Def}

\subsection{Построение бора.}%
\label{ssub:Построение бора.}

Для добавления строки в бор мы: \\
Прочитав очередной символ в цикле по строке, переходим по соответсвующему ему ребру или создаем такое ребро если потребуется. \\
После завершения строки помечаем последнюю вершину как терминальную.

Таким образом, бор строится за линейное по сумме всех строк в наборе время.

\subsection{Преобразование бора в автомат.}%
Будем понимать вершины бора и соответсвующие им строки как состояния конечного детерменированного автомата. Однако мы сталкиваемся с проблемой, ребер бора не достаточно для отражения всех возможных переходов между состояниями автомата. 
\begin{example}
	Даю установку: Вы видите картинку бора для строк adam и dprk.
	Ребра бора не отражают тот факт, что перейдя под воздействием символов $"ad"$ в некоторое состояние  $S_1$ мы все еще можем перейти в состояние  $S_2$.
\end{example}

\begin{Def}
	\textbf{Суффиксная ссылка} вершины $v$ --- ссылка (мнимая стрелка в боре) на вершину $u$, такую, что состояние $u$ --- наибольший собственный суффикс состояния $v$, а если такой вершины  $u$ нет, то ссылка на корень. По определению, ссылка из корня ведет в корень.
\end{Def}

\begin{example}
	Для бора строк $"adam"$ и $"dprk"$ единственной суффиксной ссылкой, не ведущей в корень, будет ссылка из состояния $"ad"$, в состояние $"d"$, зачеркнутая на рисунке выше.
\end{example}

\subsubsection{Нахождение суффиксных ссылок.}

\textbf{Чтобы найти суффиксную ссылку} для вершины $v$: 
Если $v$ -- корень, то и его суффиксная ссылка тоже корень.
В противном случае: \\
Пусть $c$ --- буква, преводящая из родителя в вершину $v$. \\
Рассмотрим в качестве текущей вершины суффиксную ссылку родителя. \\
Пока в рассматриваемой вершине нет ребра, соответсвующего букве $c$, будем прыгать дальше, рассматривая ее суффиксную ссылку. \\
Если мы уперлись в корень, то корень и является суффиксной ссылкой вершины $v$. \\
Если мы нашли вершину $u$, с ребром  $c$, то суффиксной ссылкой будет вершина, в которую ребро  $c$ переводит  вершину $u$.

Концептуально мы берем наибольший собственный суффикс родителя и откусываем от него по одной букве слева, пока не получится подстрока, которая добавлением одного символа становится собственным суффиксом нашей исходной строки.

\begin{listing}[language = C++]
    auto get_suflink(Node_t* node){
        
        if (node == root) return root;

        auto last_c = node->c;
        auto parent = node->parent;

        while(parent != root && parent->go[last_c] == nullptr){
            parent = get_suflink(parent);
        }

        if (parent == root) return root;
        return parent->go[last_c];
    }
\end{listing}

Этот алгоритм терминируется, ведь на каждом шаге мы поднимаемся выше по бору, а значит рано или поздно дойдем до корня.

Мы считаем суффиксные ссылки рекурсивно, этот процесс можно \textbf{оптимизировать используя динамическое программирование}, записав суффиксную ссылку в вершину. 
Тогда мы можем ввести универсальную автоматную функцию перехода, которая не делает различия между суффиксными ссылками.

\begin{equation}
    go(node, c) = 
    \begin{cases}
        son_c &\text{если ребро бора $c$ переводит вершину $node$ в  $son_c$}
        root  &\text{если $node$ --- корень, у котрого нет ребра бора $c$}
        go(node->suflink, c) &\text{иначе}
    \end{cases}
\end{equation}

С учетом концепции универсальности перехода, переход по суффиксной ссылке вершины --- переход из суффиксной ссылки родителя по ребру $c$, где  $c$ --- ребро, которое перевело родителя в вершину.
\begin{listing}[language = C++]
    node->suflink = node->parent->suflink->go[node->c]; 
\end{listing}

Тогда чтобы посчитать суффиксные ссылки мы пойдем по дереву по слоям, высчитывая suflink и go одновременно: \\
\begin{enum}
    \item Для корня все известно.
    \item Для первого слоя suflink ведет в корень, а go вниз или по suflink в корень и по go от него.
    \item Для каждого из следующих уровней мы можем найти и suflink и go за $O(1)$, ведь для родителя, который находится уровнем выше мы уже все посчитали.
\end{enum}
Концептуально это BFS.

\subsubsection{Асимптотика построения автомата.}
Пусть $S$ -- сумма длин всех строк в наборе
\begin{enumerate}
    \item Построение бора имеет асимптотику $O()$
\end{enumerate}

