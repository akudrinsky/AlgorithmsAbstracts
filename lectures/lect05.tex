\section{Строки.}%


\subsection{Совпадение подстрок в строке.}%

Построим \textbf{полиномиальную}хеш-функцию, которая каждой строке в соответствие ставит число.
\[h_{p, m}(c_{0}c_{1}...c_{n}) = (c_0 \cdot p^{n - 1} + c_1 \cdot p^{n-2} + ... + a_{n - 2} \cdot p + a_{n - 1}) \% \]

При помощи схемы Горнера, такая функция считается за линейное время, ведь $h_{p, m}(c_{0}c_{1}...c_{n}) = (...(((c_0 \cdot p + c_1))p + c_2)p + c_3)...)p + a_{n-1}$

Так как мы имеем дело с подстроками одной большой строки, мы можем сделать предподсчет хеш-функции для всех префиксов большой строки, а дальше воспользоваться свойством хеша:
\[
	h(S[l, r)) = h(S[0, r)) - h(S[0, l))*p^{r - l + 1}
.\] 

Таким образом, после линейного предподсчета, мы можем сравнивать строки по их хешу за константное время.


\subsection{Алгоритм Рабина -- Карпа для поиска подстроки в строке.}%

Для поиска подстроки $S$ длины $m$ в тексте $T$ длины $n$, 
\begin{enumerate}
	\item Подсчитаем $h(T[0, m))$ и $h(S[0, m))$, а также $p^m$.
	\item В цикле по всем $i$ от  $0$ до $n - m$
		\begin{enumerate}
			\item Считаем $h(T[i, m + i))$ и сравниваем его с $h(S[0, m))$. 
			\item В случае равенства, опционально, можно провести проверку наивным посимвольным сравнением или выборочным сравнением символов, для исключения малейшей вероятности коллизии.
		\end{enumerate}
\end{enumerate}

Алгоритм работает за линейное время $O(n + m)$, однако он не устойчив перед коллизиями хеш-функции, дополнительная обработка которых увеличивает время работы.


\subsection{Алгоритм Кнута -- Морриса -- Пратта для поиска подстроки в строке.}%

Введем для строки $S$ префикс-функцию $\pi$ 
\[
	\pi(i) = max_\limists_{k \in [0, i]}\{k: S[0, k) == S[i + 1 - k, i +1)\}$ 
\]
-- длина наибольшего несобственного суффикса подстроки S[:i], который равен префиксу такой же длины. $\pi(0) = 0$ по определению.
\begin{example}
	$S = "adam"$. 
	$\pi(0) = 0$. \\
	$pi(1) = 0$, ведь у строки  $"a"$ есть только пустой собственный суффикс. \\
	$pi(2) = 0$, ведь у строки $"ab"$ нет собственного суффикса, совпадающего с префиксом той же длины. \\
	$pi(3) = 1$, ведь у строки  $"ada"$ есть собственный суффикс  $"a"$ длины 1, который совпадает с префикосм  $"a"$. \\
	$pi(4) = 0$. \\
\end{example}

Нетрудно представить себе наивный алгоритм, подсчитывающий префикс-функцию строки за $O(n^3)$. Оптимизируем его.



 \begin{prop}
	 $\pi(i + 1) \leq \pi(i) + 1$
\end{prop}
\begin{proof}
	Рассмотрим суффикс, оканчивающийся на позиции $i + 1$ и имеющий длину $\pi(i + 1)$. Удалив из него последний элемент, мы получим суффикс, оканичающийся на позиции $i$ и имеющий длину  $\pi(i + 1) - 1$\\
	Однака, мы определили $\pi(i)$ максимальную длину суфикса  $\Rightarrow$ $\pi(i) \geq \pi(i + 1) - 1$.
	Даю установку: Вы видите рисунок 1.
\end{proof}

\begin{prop}
	Если $S[\pi(i)] == S[i + 1]$, то  $\pi(i + 1) == \pi(i) + 1$.
\end{prop}
\begin{proof}
	Условие говорит нам, что после префикса длины $\pi(i)$ находится символ, который совпадает с символом, который находится после суффикса, оканичвающегося на позиции $i$. То есть наибольший суффикс, заканчивающийся на позиции $i + 1$ содержит в себе все символы суффикса, заканчивающегося на позиции $i$ и еще один символ. Это и записано в правой части.
\end{proof}

Пользуясь вторым свойством, мы сможем частично оптимизировать подсчет. Если же окажется что условие равенства символов не выполняется, мы будем искать суффикс меньшей длины следующим образом:
Мы знаем, что $S[1, \pi(\pi(i)))$ -- суффикс подстроки  $S[1, i)$ \\
Тогда подсчет можно свести к циклу:
\begin{enumerate}
\setcounter{enumi}{0}
	\item $k = \pi(i)$.
	\begin{enumerate}
		\item Если $S[i + 1] == S[k]$, то $\pi(i + 1) = k + 1$.
		\item Если же $k == 0$, то $\pi(i + 1) = 0$.
	\end{enumerate}
	\item $k = \pi(k)$. Перейти к пунту 1.
\end{enumerate}

\begin{prop}
	Оптимизированный алгоритм подсчета префикс-функции имеет ассимптотику $O(n)$.	
\end{prop}
\begin{proof}
	Из вышедоказанного утверждения мы знает что на каждой итерации, k увеличиваниеся не более чем на 1.
\end{proofroof}

