\section{Сложность вычислений.}%
\label{sec:Сложность вычислений.}

Всю свою жизнь вы занимались Fine-grained complexity, 
то есть имея алгоритм за $O(n^2)$ сделать алгоритм за  $O(n\log n)$.

В сложности вычислений мы отходим от тонких материй, переставая различать $O(n)$ и  $O(n^2)$ 
и будем считать эффективными -- задачи класса  $P$.

\begin{Def}
    \textbf{Класс задач P} --- класс задач, которые решаются за полиномиальное время.
\end{Def}

Кроме того, мы поймем какие задачи на сегодняшний день не представляется возможным решать за $O(poly(n))$.

\subsection{Машина тьюринга.}%
\label{sub:Машина тьюринга.}
\begin{Def}
    \textbf{Машина Тьюринга} --- набор объектов $(\Sigma, \Gama, Q, \delta, q_s, q_a, q_r)$, где :
    \begin{itemize}
        \item $\Sigma$ --- входной алфавит, символы, которые могут быть переданы на вход.
        \item $\Gama$ --- ленточный алфавит, то что может быть напечатано на ленту. 
            $\Sigma \subset \Gama$, $\# \in \Gama$ --- пробельный символ, $\Gama$ --- конечно.
        \item $Q$ --- множество состояний, $Q$ --- конечно.
        \item $\delta: Q \times \Gama \to Q \times \Gama \{L, N, R\}$ ---- функция переходов, 
            получив состояние и символ, она вернет состояние, в которое нужно перейти, символ, который нужно вывести, 
            а также направление, по которому нужно сдвинуться по ленте.
        \item $q_s$ --- стартовое состояние.
        \item $q_a$ --- терминальное состояние, свидетельствующее о том, что полученное слово --- хорошее.
        \item $q_r$ --- терминальное состояние, свидетельствующее о том, что полученное слово --- плохое.
    \end{itemize}
\end{Def}

То есть наша машина будет рассматривать слово, определяя, лежит ли оно в языке, и давать бинарный ответ --- да или нет.

Не будем формально вводить вычисление, интуитивно говоря, мы имеем полоску бумаги, разделенную на клетки, изначально заполненные пробелами.
На каком-то куске ленты написано входное слово $x \in \Sigma*$, которе мы будем определать на принадлежность рассматриваемому языку.

\begin{Example}
   Правда ли что $x$ --- правильная скобочная последовательность.
\end{Example}

В начальной конфигурации головка указывает на начало слова $x$ и машина находится в состоянии  $q_s$. 
На каждый такт работы машины, мы применяем функцию  $\delta$. Сама функция как бы зашита в управляющее устройство машины. 

Применение  $\delta$ продолжается пока мы не придем в терминальное состояние  $q_a$ или  $q_r$.

\begin{Def}
     Будем говорить, что \textbf{машина распознает язык $L \subset \Sigma*$ за вермя $T$}, 
     если при любом входе из языка $L$ она приходит в верное терминальное состояние не больше чем за $T$. 
\end{Def}

\subsubsection{Многоленточная машина.}
\begin{Def}
    \textbf{Многоленточная машина Тьюринга} --- набор объектов $(\Sigma, \Gama, Q, \delta, k, q_s, q_a, q_r)$, где:
    \begin{itemize}
        \item $k$ --- количество лент.
        \item $\delta: Q \times \Gama^k \to Q \times \Gama^k \times \{L, N, R\}$.
    \end{itemize}
\end{Def}

То есть на каждой ленте есть своя головка, котороя по ней перемещается, независимо от других головок.

\begin{Theorem}
    Если язык $L$ распознается на  $k$-ленточной машине за  $T(n)$, то существует одноленточная машина, распознающая $L$ за  $O(k \cdot T^2(n)$ 
\end{Theorem}

\begin{Rem}
    Именно поэтому не имеет смысла различать по эффективности полиномиальное время. 
\end{Rem}

\begin{Def}
    $DTIME(T(n))$ ---  класс языков, которые распознаются за $T$ на многоленточной машине.
\end{Def}

\begin{Def}
    Класс языков $P$ ---  $\cup_{c = 1}^{\inf} DTIME(n^c)$.
\end{Def}

\begin{Def}
    Класс языков $EXP$ ---  $\cup_{c = 1}^{\inf} DTIME(2^{n^c})$.
\end{Def}

\subsubsection{Недетерминированная машина.}
\begin{Def}
    \textbf{Недетерминированная машина Тьюринга} --- набор объектов $(\Sigma, \Gama, Q, \delta, k, q_s, q_a, q_r)$, где:
    \begin{itemize}
        \item $\delta: Q \times \Gama ^ k \rightrightarrows Q \times \Gama ^k \times \{L, N, R\} ^ k$. --- многозначная функция, 
            то есть для одного входного значения есть несколько переходов, из них мы выбираем произвольно. 
    \end{itemize}
\end{Def}

\begin{Def}
   Недетерминированная машина \textbf{принимает слово $x$} если хотябы в одной из ветвей вычислений достигается $q_a$. 
\end{Def}
\begin{Def}
   Говорим что $M$ отвергает  $x$, если она его не принимает. 
   Время работы --- максимальная длина ветви.
\end{Def}

\begin{Def}
    $NTIME(T(n))$ --- класс языков, которые распознаются на недетерминированной машине тьюринга за время  $T(n)$.
\end{Def}

\begin{Def}
    $NP$ --- $\cup_{c = 1}^{\inf} NTIME(n^c)$.
\end{Def}

\begin{note}
   Здесть $NP$ ---  \textbf{Nondeterministic-polynomial}, а вовсе не Non-polynomial. 
\end{note}

\begin{Theorem}
   $P \subset NP \subset EXP$ 
\end{Theorem}
\begin{proof} \ \\
   Перво вложение верно очевидным образом. \\
   Второе вложение верно так как в каждой точке имеется константное количество ветвлений переходов, а значи их все можно смоделировать за экспоненциальное время.
\end{proof}

\begin{Def}
    Язык $A$ \textbf{сводится полиномиально к} языку $B$: $A \leq_p B$ --- 
    существует полиномиально-вычислимая функция  $f: \forall x \hookrightarrow x \in A \ifff f(x) \in B$.
\end{Def}
\begin{note}
    То есть мы можем однозначно определить лежит ли $x$ в  $A$, определив принадлежность $f(x)$ к $B$.
\end{note}

\begin{Def}
   \textbf{NP-трудный} --- язык, такой что $\forall A \in NP \hookrightarrow A \leq_p B$
\end{Def}

\begin{Def}
   \textbf{NP-полный} --- NP-трудный язык, который и сам лежит в  $NP$.
\end{Def}
\begin{note}
   То есть это значит самый сложный в классе NP. 
\end{note}

\begin{example}
    Примеры NP-полных языков. 
    \begin{itemize}
        \item $SAT = {\phi: phi \text{пропозициональная выполнимая формула.}}$
        \item $SAT = {\phi: phi \text{пропозициональная выполнимая формула в 3-КНФ.}}$
    \end{itemize} 
\end{}
